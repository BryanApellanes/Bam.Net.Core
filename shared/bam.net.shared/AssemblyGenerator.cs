using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using Bam.Net.ServiceProxy;
using CsQuery.ExtensionMethods;

namespace Bam.Net
{
    public abstract class AssemblyGenerator : IAssemblyGenerator
    {
        public AssemblyGenerator()
        {
            _generatedAssemblies = new Dictionary<string, Assembly>();
            _sourceHashes = new Dictionary<string, string>();
            _fileHashes = new Dictionary<string, string>();
            HashAlgorithm = HashAlgorithms.SHA1;
        }
        /// <summary>
        /// The name of the assembly to generate, if this values is null a random name is generated.
        /// </summary>
        public string AssemblyName { get; set; }
        public string SourceDirectoryPath { get; set; }
        
        /// <summary>
        /// Metadata file holding GeneratedAssemblyInfo
        /// </summary>
        public string InfoFileName { get; set; }
        public HashAlgorithms HashAlgorithm { get; set; }
        public string Seed { get; set; }
        
        /// <summary>
        /// The path to the geninfo file which holds meta data about
        /// the Assembly generated by this generator.
        /// </summary>
        public string GeneratedAssemblyInfoPath { get; set; }

        public GeneratedAssemblyInfo GenerateAssembly()
        {
            if (!_sourceWritten)
            {
                WriteSource();
            }
            GeneratedAssemblyInfo result = new GeneratedAssemblyInfo(InfoFileName, GetAssembly());
            result.Save();
            return result;
        }

        bool _sourceWritten;
        public void WriteSource()
        {
            WriteSource(SourceDirectoryPath);
            _sourceWritten = true;
        }
        
        public abstract void WriteSource(string writeSourceDir);

        public abstract Assembly CompileAssembly(out byte[] bytes);
       
        protected bool FilesHashed { get; set; }

        static Dictionary<string, Assembly> _generatedAssemblies;
        protected virtual Assembly GetAssembly()
        {
            string sourceHash = HashSource(!FilesHashed);
            if (_generatedAssemblies.ContainsKey(sourceHash))
            {
                return _generatedAssemblies[sourceHash];
            }

            Assembly compiled = CompileAssembly(out byte[] bytes);
            RuntimeConfig config = RuntimeSettings.GetConfig();
            string assemblyFile = Path.Combine(config.GenDir, AssemblyName);
            
            throw new NotImplementedException("finish this, make sure that the output directory exists");
            
            File.WriteAllBytes(assemblyFile, bytes);
            _generatedAssemblies.AddMissing(sourceHash, compiled);
            return compiled;
        }

        Dictionary<string, string> _sourceHashes;
        /// <summary>
        /// Calculates the SHA1 hash for all source files found, one at a time, concatenating each to the result
        /// of the previous operation. 
        /// </summary>
        /// <returns></returns>
        protected string HashSource(bool rehashFiles = true)
        {
            if (rehashFiles)
            {
                HashFiles();
            }
            
            DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectoryPath);
            SortedSet<string> sortedFilePaths = new SortedSet<string>();
            sourceDirectory.GetFiles("*.cs").Each(fi => sortedFilePaths.Add(fi.FullName));
            string currentHash = (Seed ?? "").Hash(HashAlgorithm);
            foreach (string filePath in sortedFilePaths)
            {
                FileInfo file = new FileInfo(filePath);
                currentHash = $"{currentHash}{HashFile(filePath)}".Hash(HashAlgorithm);
            }

            return currentHash;
        }

        Dictionary<string, string> _fileHashes;
        protected void HashFiles()
        {
            DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectoryPath);
            if (sourceDirectory.Exists)
            {
                foreach (FileInfo file in sourceDirectory.GetFiles("*.cs"))
                {
                    HashFile(file.FullName);
                }
                
                FilesHashed = true;
            }
        }

        private string HashFile(string filePath)
        {
            if (_fileHashes.ContainsKey(filePath))
            {
                return _fileHashes[filePath];
            }

            string contentHash = new FileInfo(filePath).ContentHash(HashAlgorithm);
            _fileHashes.AddMissing(filePath, contentHash);
            return contentHash;
        }
    }
}