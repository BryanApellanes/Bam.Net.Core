using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using Bam.Net.ServiceProxy;
using CsQuery.ExtensionMethods;

namespace Bam.Net
{
    public abstract class AssemblyGenerator : IAssemblyGenerator
    {
        public AssemblyGenerator()
        {
            _generatedAssemblies = new Dictionary<string, Assembly>();
            _sourceHashes = new Dictionary<string, string>();
            _fileHashes = new Dictionary<string, string>();
            HashAlgorithm = HashAlgorithms.SHA1;
        }
        
        public string SourceDirectoryPath { get; set; }
        
        /// <summary>
        /// Metadata file holding GeneratedAssemblyInfo
        /// </summary>
        public string InfoFileName { get; set; }
        public HashAlgorithms HashAlgorithm { get; set; }
        public string Seed { get; set; }
        
        /// <summary>
        /// The path to the geninfo file which holds meta data about
        /// the Assembly generated by this generator.
        /// </summary>
        public string GeneratedAssemblyInfoPath { get; set; }

        public GeneratedAssemblyInfo GenerateAssembly()
        {
            GeneratedAssemblyInfo result = new GeneratedAssemblyInfo(InfoFileName, GetAssembly());
            result.Save();
            return result;
        }
        
        public void WriteSource()
        {
            WriteSource(SourceDirectoryPath);
        }
        
        public abstract void WriteSource(string writeSourceDir);

        public abstract Assembly Compile();
       
        protected bool FilesHashed { get; set; }

        Dictionary<string, Assembly> _generatedAssemblies;
        protected virtual Assembly GetAssembly()
        {
            string sourceHash = HashSource(!FilesHashed);
            if (_generatedAssemblies.ContainsKey(sourceHash))
            {
                return _generatedAssemblies[sourceHash];
            }

            Assembly compiled = Compile();
            _generatedAssemblies.AddMissing(sourceHash, compiled);
            return compiled;
        }


        Dictionary<string, string> _sourceHashes;
        /// <summary>
        /// Calculates the SHA1 hash for all source files found, one at a time, concatenating each to the result
        /// of the previous operation. 
        /// </summary>
        /// <returns></returns>
        protected string HashSource(bool rehashFiles = true)
        {
            if (rehashFiles)
            {
                HashFiles();
            }
            
            DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectoryPath);
            SortedSet<string> sortedFilePaths = new SortedSet<string>();
            sourceDirectory.GetFiles("*.cs").Each(fi => sortedFilePaths.Add(fi.FullName));
            string currentHash = Seed.Hash(HashAlgorithm);
            foreach (string filePath in sortedFilePaths)
            {
                FileInfo file = new FileInfo(filePath);
                currentHash = $"{currentHash}{HashFile(filePath)}".Hash(HashAlgorithm);
            }

            return currentHash;
        }

        Dictionary<string, string> _fileHashes;
        protected void HashFiles()
        {
            DirectoryInfo sourceDirectory = new DirectoryInfo(SourceDirectoryPath);
            Parallel.ForEach(sourceDirectory.GetFiles("*.cs"), (fi) => { HashFile(fi.FullName); });
            FilesHashed = true;
        }

        private string HashFile(string filePath)
        {
            if (_fileHashes.ContainsKey(filePath))
            {
                return _fileHashes[filePath];
            }

            string contentHash = new FileInfo(filePath).ContentHash(HashAlgorithm);
            _fileHashes.AddMissing(filePath, contentHash);
            return contentHash;
        }
    }
}